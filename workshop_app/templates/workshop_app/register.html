{% extends 'workshop_app/base.html' %}

	{% block title %}
		Register
	{% endblock %}

{% block content %}

	<style type="text/css">
    	label.required::after {
    	content: "*";
    	color: red;
		}

		.errorlist {
      color: red;
    }
	</style>

	<div class="container">
		<div class="row justify-content-center">
			<div class="col-md-10 col-lg-8">
				<div class="card glass">
					<div class="card-body p-4">
						<h3 class="mb-3">Coordinator Registration</h3>
						<p class="text-muted">I'll ask one thing at a time. Easier, faster.</p>
						<form action="" method="post" id="reg-form">
							{% csrf_token %}
							<div class="form-row">
								<div class="col-12">
									{{ form.non_field_errors }}
								</div>
							</div>
							<div id="stepper" class="mb-3"></div>
							<div id="reg-fields" class="form-group">{{ form.as_p }}</div>
							<div class="d-flex justify-content-between mt-3">
								<button type="button" id="prevBtn" class="btn btn-outline-info" style="display:none">Back</button>
								<button type="button" id="nextBtn" class="btn btn-primary">Next</button>
								<button type="submit" id="submitBtn" class="btn btn-success" style="display:none">Register</button>
							</div>
						</form>
					</div>
				</div>
			</div>
		</div>
	</div>

	<script>
	(function() {
	  const container = document.getElementById('reg-fields');
	  if (!container) return;
	  const fields = Array.from(container.querySelectorAll('p'));
	  // Group fields into fewer steps (e.g., 6 logical steps)
	  const groups = [
	    ['username', 'email'],
	    ['password', 'confirm_password'],
	    ['first_name', 'last_name', 'title'],
	    ['phone_number', 'state'],
	    ['institute', 'department'],
	    ['location', 'how_did_you_hear_about_us']
	  ];
	  // Map <p> blocks by their input name to re-order/display in groups
	  const byName = Object.fromEntries(fields.map(p => {
	    const input = p.querySelector('input, select, textarea');
	    return [input && (input.name || input.id), p];
	  }));
	  const ordered = groups.map(names => names.map(n => byName[n]).filter(Boolean));
	  let idx = 0;
	  const nextBtn = document.getElementById('nextBtn');
	  const prevBtn = document.getElementById('prevBtn');
	  const submitBtn = document.getElementById('submitBtn');
	  const stepper = document.getElementById('stepper');

	  fields.forEach(p => { p.classList.add('mb-3'); });

	  function renderStepper() {
	    const total = ordered.length;
	    stepper.innerHTML = `<small class="text-muted">Step ${idx+1} of ${total}</small>`;
	  }

	  function showCurrent() {
	    // Hide all
	    fields.forEach(p => p.style.display = 'none');
	    // Show current group
	    ordered[idx].forEach(p => p.style.display = 'block');
	    prevBtn.style.display = idx > 0 ? 'inline-block' : 'none';
	    nextBtn.style.display = idx < ordered.length - 1 ? 'inline-block' : 'none';
	    submitBtn.style.display = idx === ordered.length - 1 ? 'inline-block' : 'none';
	    renderStepper();
	  }

	  function validateCurrentStep() {
	    const currentFields = ordered[idx];
	    let isValid = true;
	    
	    // Clear previous error messages
	    currentFields.forEach(p => {
	      p.querySelectorAll('.field-error').forEach(error => error.remove());
	    });
	    
	    currentFields.forEach(p => {
	      const input = p.querySelector('input, select, textarea');
	      if (!input) return;
	      
	      if (input.hasAttribute('required') && !input.value.trim()) {
	        isValid = false;
	        showFieldError(input, 'This field is required');
	      } else if (input.type === 'email' && input.value && !isValidEmail(input.value)) {
	        isValid = false;
	        showFieldError(input, 'Please enter a valid email address');
	      } else if (input.name === 'password' && input.value && input.value.length < 8) {
	        isValid = false;
	        showFieldError(input, 'Password must be at least 8 characters long');
	      } else if (input.name === 'confirm_password' && input.value) {
	        const passwordField = document.querySelector('input[name="password"]');
	        if (passwordField && input.value !== passwordField.value) {
	          isValid = false;
	          showFieldError(input, 'Passwords do not match');
	        }
	      }
	    });
	    
	    return isValid;
	  }

	  function showFieldError(field, message) {
	    const errorDiv = document.createElement('div');
	    errorDiv.className = 'field-error text-danger small mt-1';
	    errorDiv.textContent = message;
	    field.parentNode.appendChild(errorDiv);
	  }

	  function isValidEmail(email) {
	    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
	    return emailRegex.test(email);
	  }

	  nextBtn.addEventListener('click', () => {
	    if (validateCurrentStep() && idx < ordered.length - 1) {
	      idx += 1;
	      showCurrent();
	    }
	  });
	  prevBtn.addEventListener('click', () => {
	    if (idx > 0) idx -= 1;
	    showCurrent();
	  });

	  showCurrent();
	})();
	</script>
{% endblock %}
